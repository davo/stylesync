//
//  CodeGenerator.swift
//  SketchStyleExporter
//
//  Created by Dylan Lewis on 12/08/2017.
//  Copyright © 2017 Dylan Lewis. All rights reserved.
//

import Foundation

/// A `String` of a code template, where replacable ranges are denoted as
/// `<replacableDeclaration>` and `</replacableDeclaration>`, and replaceable
/// elements are denoted as `<#=replaceableElement#>`
typealias Template = String

struct CodeGenerator {
	// MARK: - Stored properties
	
	let template: Template
	let codeTemplateReplacables: [[CodeTemplateReplacable]]
	
	// MARK: - Initializer
	
	/// Creates a `CodeGenerator` with a given template and an array of groups
	/// of elements to replace. Each element of each group will have code
	/// generated for it, using the provided template.
	///
	/// - Parameters:
	///   - template: The template of code to generate.
	///   - codeTemplateReplacables: An array of groups of elements to replace.
	///								 Each element of each group will have code
	/// 							 generated for it, using the provided
	///								 template.
	init(template: Template, codeTemplateReplacables: [[CodeTemplateReplacable]]) {
		self.template = template
		
		let headerLines = """
		Automatically generated by SketchStyleExporter
		https://github.com/dylanslewis/SketchStyleExporter
		"""
		let generatedDocumentHeaderLines = headerLines.components(separatedBy: "\n").map(HeaderLine.init)
		self.codeTemplateReplacables = [generatedDocumentHeaderLines] + codeTemplateReplacables
	}
	
	// MARK: - Code Generation
	
	/// Code generated by replacing the `codeTemplateReplacables` in the
	/// `template`.
	var generatedCode: String {
		var codeLines = template.components(separatedBy: "\n")
		
		// Iterate over each group of `codeTemplateReplacables` and
		codeTemplateReplacables.forEach({ codeLines = codeLines.replacingCodePlaceholders(usingReplacementItems: $0) })
		codeLines.validateCodeLines()
		return codeLines.joined(separator: "\n")
	}
}

// MARK: - HeaderLine

private extension CodeGenerator {
	/// A line of text to be shown in the header of the generated file.
	struct HeaderLine: CodeTemplateReplacable {
		static let declarationName: String = "generatedFileHeader"
		let headerLine: String
		
		var replacementDictionary: [String: String] {
			return ["headerLine": headerLine]
		}
	}
}

// MARK: - Helpers

private extension Array where Iterator.Element == String {
	/// Replaces all placeholders in each of the array's code lines, by looking
	/// up the corresponding value in the `replacementDictionary`.
	///
	/// - Parameter replacementDictionary: A dictionary where the keys are the
	///									   replacable element's placeholder and
	///									   the value is the replacement for that
	///									   placeholder.
	/// - Returns: The original array with replaced placeholders.
	func replacingCodePlaceholders(usingReplacementDictionary replacementDictionary: [String: String]) -> [String] {
		return map({ line -> String in
			var codeLineWithReplacedPlaceholders = line
			replacementDictionary.forEach({ (arg) in
				let (replacementKey, replacementValue) = arg
				codeLineWithReplacedPlaceholders = codeLineWithReplacedPlaceholders
					.replacingOccurrences(of: replacementKey.codePlaceholderReference, with: replacementValue)
			})
			return codeLineWithReplacedPlaceholders
		})
	}
	
	/// Replaces code placeholders in an array of code lines by finding the
	/// start declaration and end declaration, getting the replacement template
	/// and then replacing the placeholders in that template using each of the
	/// replacement items. The original code placeholders are then removed from
	/// the code lines.
	///
	/// - Parameters:
	///   - replacementItems: The items used to replace the code placeholders.
	///   - codeLines: The code lines that contain the code placeholders
	/// - Returns: The code lines with replaced code placeholders.
	func replacingCodePlaceholders(usingReplacementItems replacementItems: [CodeTemplateReplacable]) -> [String] {
		guard let firstReplacementItem = replacementItems.first else {
			print("⚠️ Unable to find element type.")
			return self
		}
		
		let replacementElementType = type(of: firstReplacementItem)
		let declarationName = replacementElementType.declarationName
		
		var codeLinesWithReplacement = self
		var containsDeclarationForType = true
		repeat {
			guard
				let declarationStartIndex = codeLinesWithReplacement.index(where: { $0.contains(declarationName.declarationStartReference) }),
				let declarationEndIndex = codeLinesWithReplacement.index(where: { $0.contains(declarationName.declarationEndReference) })
			else {
				containsDeclarationForType = false
				continue
			}
			
			// Extract the template for the given replacement item type.
			let replacementItemTemplate = Array(codeLinesWithReplacement[declarationStartIndex.advanced(by: 1)..<declarationEndIndex])
			let codeLinesWithReplacedPlaceholders = replacementItems
				.map({ return replacementItemTemplate.replacingCodePlaceholders(usingReplacementDictionary: $0.replacementDictionary) })
				.flatMap({ $0 })
			codeLinesWithReplacement.replaceSubrange(declarationStartIndex...declarationEndIndex, with: codeLinesWithReplacedPlaceholders)
		} while containsDeclarationForType == true
		
		return codeLinesWithReplacement
	}
	
	/// Checks that there are no placeholders remaining in the code lines. If
	/// any are found, a warning is printed to the console.
	func validateCodeLines() {
		enumerated().forEach { arg in
			let (offset, element) = arg
			if element.contains("<#=") {
				print("⚠️ Unreplaced placeholder at line \(offset):\n" + element + "\n")
			}
		}
	}
}

private extension String {
	/// Wraps the current string in a code placeholder reference.
	var codePlaceholderReference: String {
		return "<#=" + self + "#" + ">"
	}
	
	/// Wraps the current string in a declaration start reference.
	var declarationStartReference: String {
		return "<" + self + ">"
	}
	
	/// Wraps the current string in a declaration end reference.
	var declarationEndReference: String {
		return "</" + self + ">"
	}
}
